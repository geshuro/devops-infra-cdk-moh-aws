/* eslint-disable no-console */
import type { PostConfirmationTriggerHandler, PostConfirmationConfirmSignUpTriggerEvent } from 'aws-lambda';
import {
  CognitoIdentityProviderClient,
  AdminAddUserToGroupCommand,
  GetGroupCommand,
  CreateGroupCommand,
  ResourceNotFoundException,
} from '@aws-sdk/client-cognito-identity-provider';

const config = loadConfig();
const client = new CognitoIdentityProviderClient({});

interface Identity {
  providerName: string;
}

export const handler: PostConfirmationTriggerHandler = async (event) => {
  // Make sure that this is the right event
  if (event.triggerSource !== 'PostConfirmation_ConfirmSignUp') {
    return event;
  }

  const userRole = determineUserRoleToAssign(event);

  if (!userRole) {
    console.error('Unable to find the user role.');
    return event;
  }

  const { userPoolId, userName } = event;

  await ensureGroupForUserRole({ userPoolId, userRole });
  await addUserToRoleGroup({ userPoolId, userName, userRole });
  return event;
};

const determineUserRoleToAssign = (event: PostConfirmationConfirmSignUpTriggerEvent) => {
  if (isExternalUser(event)) {
    const idpName = getExternalIdpName(event);
    if (!idpName) {
      console.error('Unable to determine IDP name');
      return undefined;
    }
    return config.externalIdpUserRoles[idpName];
  }

  // Not an external user so we'll assume self-signup
  return config.selfSignupUserRole;
};

const isExternalUser = (event: PostConfirmationConfirmSignUpTriggerEvent) =>
  event.request.userAttributes['cognito:user_status'] === 'EXTERNAL_PROVIDER';

const getExternalIdpName = (event: PostConfirmationConfirmSignUpTriggerEvent) => {
  const identitiesStr = event.request.userAttributes.identities;
  if (!identitiesStr) {
    return undefined;
  }
  try {
    const identities: Identity[] = JSON.parse(identitiesStr);
    return identities[0]?.providerName;
  } catch (e) {
    console.error(e);
    return undefined;
  }
};

const toCognitoRoleGroupName = (userRole: string) => `rbac:${userRole}`;

async function addUserToRoleGroup(props: { userName: string; userPoolId: string; userRole: string }) {
  await client.send(
    new AdminAddUserToGroupCommand({
      UserPoolId: props.userPoolId,
      Username: props.userName,
      GroupName: toCognitoRoleGroupName(props.userRole),
    }),
  );
}

async function ensureGroupForUserRole(props: { userPoolId: string; userRole: string }) {
  let groupExists: boolean;
  try {
    await client.send(
      new GetGroupCommand({ UserPoolId: props.userPoolId, GroupName: toCognitoRoleGroupName(props.userRole) }),
    );
    groupExists = true;
  } catch (e) {
    if ((e as ResourceNotFoundException).name === 'ResourceNotFoundException') {
      groupExists = false;
    } else {
      throw e;
    }
  }

  if (!groupExists) {
    await client.send(
      new CreateGroupCommand({
        UserPoolId: props.userPoolId,
        GroupName: toCognitoRoleGroupName(props.userRole),
        Description: `Autogenerated group for role ${props.userRole}`,
      }),
    );
  }
}

/**
 * Load config from process environment.
 *
 * We're not using `class-validator` here because it adds 1MB
 * to the package size.
 */
function loadConfig() {
  let externalIdpUserRoles: Record<string, string> = {};
  const externalIdpUserRolesStr = process.env.APP_EXTERNAL_IDP_USER_ROLES;
  if (externalIdpUserRolesStr) {
    try {
      externalIdpUserRoles = JSON.parse(externalIdpUserRolesStr);
    } catch {
      // may be not configured if there are no external IDPs
    }
  }

  return {
    selfSignupUserRole: process.env.APP_SELF_SIGNUP_USER_ROLE,
    externalIdpUserRoles,
  };
}
